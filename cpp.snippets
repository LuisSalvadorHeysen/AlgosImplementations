snippet BellmanFord "Bellman Ford"
struct BellmanFord {
    vector<int> d;
    bool negative_cycle;

    BellmanFord(int n, int src, vector<vector<int>> &edges) {
        d.assign(n, INF);
        d[src] = 0;

        for (int i = 0; i < n; ++i) {
            negative_cycle = false;
            for (vector<int> edge : edges) {
                if (d[edge[0]] < INF && d[edge[1]] > d[edge[0]] + edge[2]) {
                    d[edge[1]] = d[edge[0]] + edge[2];
                    negative_cycle = true;
                }
            }
        }
    }
};
endsnippet

snippet LinearSieve "Linear Sieve code"
vector<int> primes;
bool is_composite[MAX];

void sieve(int n) {
    fill(is_composite, is_composite + n, false);
    primes.clear();
    is_composite[1] = true;
    for (int i = 2; i < n; ++i) {
        if (!is_composite[i]) primes.pb(i);
        for (int j = 0; j < int(primes.size()) && i * primes[j] < n; ++j) {
            is_composite[i * primes[j]] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
endsnippet

snippet bfs "bfs code"
void bfs(int src) {
    queue<int> q;
    q.push(src);
    d[src] = 0;

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        for (int nbr : adj[node]) {
            if (d[nbr] == -1) {
                d[nbr] = 1 + d[node]; 
                q.push(nbr);
            }
        }
    }
}
endsnippet

snippet LCA "LCA code"
int up[MAX][LOG]; // up[v][j] = 2^j th ancestor of node v
vector<vector<int>> adj;
int depth[MAX];

void dfs(int node, int fat) {
    for (int nbr : adj[node]) {
        if (nbr == fat)
            continue;

        depth[nbr] = 1 + depth[node];

        up[nbr][0] = node;
        for (int j = 1; j < LOG; ++j)
            up[nbr][j] = up[up[nbr][j - 1]][j - 1];

        dfs(nbr, node);
    }
}

int get_lca(int a, int b) {
    if (depth[a] < depth[b])
        swap(a, b);

    int diff = depth[a] - depth[b];
    for (int i = 0; i < LOG; ++i) {
        if (diff & (1 << i)) {
            a = up[a][i];
        }
    }

    if (a == b)
        return a;

    for (int i = LOG - 1; i >= 0; --i) {
        if (up[a][i] != up[b][i]) {
            a = up[a][i];
            b = up[b][i];
        }
    }
    return up[a][0];
}
endsnippet

snippet trie "trie code"
const int ALPHABET = 26;

struct trieNode {
    trieNode *children[ALPHABET];
    int terminal;
};

trieNode *new_node() {
    trieNode *new_node = new trieNode;
    new_node->terminal = 0;
    for (int i = 0; i < ALPHABET; ++i) {
        new_node->children[i] = NULL;
    }
    return new_node;
}

void insert(trieNode *root, string word) {
    trieNode *node = root;
    for (char c : word) {
        int idx = int(c - 'a');
        if (!node->children[idx]) {
            node->children[idx] = new_node();
        }
        node = node->children[idx];
    }
    ++node->terminal;
}

void del(trieNode *root, string word) {
    trieNode *node = root;
    for (char c : word) {
        int idx = int(c - 'a');
        node = node->children[idx];
    }
    --node->terminal;
}

bool search(trieNode *root, string word) {
    trieNode *node = root;
    for (char c : word) {
        int idx = int(c - 'a');
        if (!node->children[idx]) {
            return false;
        }
        node = node->children[idx];
    }
    return node && node->terminal;
}
endsnippet

snippet DEBUG "debug code template"
#ifdef LSHT_DEBUG
#define dbg(args...){ string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }
#else
#define dbg(args...)
#endif
void err(istream_iterator<string> ) {cerr << "\n"; }
template<typename T, typename... Args>
void err(istream_iterator<string> it, T a, Args... args) {
    cerr << "\033[1;31m" << *it << " = " << a << "\033[0m" << ", ";
    err(++it, args...);
}

template <typename C>
ostream& operator<<(ostream& os, const vector<C>& c) {
    os << "[";
    for (int i = 0; i < int(c.size()); ++i) {
        if (i > 0) os << ", ";
        os << c[i];
    }
    os << "]";
    return os;
}
endsnippet

snippet binpow "binpow code"
ll binpow(ll a, ll b) {
    ll res = 1;

    while (b) {
        if (b % 2 == 1) 
            res = res * a % MOD;

        a = a * a % MOD;
        b /= 2;
    }
    return res;
}
endsnippet

snippet random "code to generate random numbers"
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

int random(int a, int b) {
    return a + rng() % (b - a + 1);
}
endsnippet

snippet is_power "function that checks if n is a sum of powers of k"
bool is_power(ll n, ll k) {
    int power = 0;
    while (n) {
        if (n % k == 0) {
            n /= k;
            ++power;
        }
        else if (n % k == 1) {
            --n;
            b[power]++;
            if (b[power] > 1) return 0;
        }
        else return 0;
    }
    return 1;
}
endsnippet

snippet Dijkstra "Dijkstra code"
struct Dijkstra {
    vector<ll> d;
    vector<int> fat;
    vector<bool> vis;
 
    Dijkstra(int src, int n, vector<vector<pair<int, int>>> adj) {
        d.assign(n, INF);
        vis.assign(n, false);
        d[src] = 0;
        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;
        q.push({0, src});
        while (!q.empty()) {
            int node = q.top().ss;
            q.pop();
            if (vis[node]) continue;
            vis[node] = true;
            for (pair<int, int> nbr : adj[node]) {
                if (d[nbr.ff] > d[node] + nbr.ss) {
                    d[nbr.ff] = d[node] + nbr.ss;
                    q.push({d[nbr.ff], nbr.ff});
                }
            }
        }
    }
};
endsnippet

snippet matrixmul "function that multiplies two matrices"
vector<vector<ll>> multiply(vector<vector<ll>> a, vector<vector<ll>> b) {
    int ca = int(a[0].size()), cb = int(b[0].size()), ra = int(a.size()), rb = int(b.size());
    vector<vector<ll>> res(ra, vector<ll>(cb));

    for (int i = 0; i < ra; ++i) {
        for (int j = 0; j < cb; ++j) {
            for (int k = 0; k < ca; ++k) {
                res[i][j] += a[i][k] * b[k][j];
                res[i][j] %= MOD;
            }
        }
    }

    return res;
}
endsnippet

snippet custom_hash "custom hash"
struct custom_hash {
    static uint64_t splitmix64(uint64_t x) {
        // http://xorshift.di.unimi.it/splitmix64.c
        x += 0x9e3779b97f4a7c15;
        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;
        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;
        return x ^ (x >> 31);
    }

    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        return splitmix64(x + FIXED_RANDOM);
    }
};
endsnippet

snippet indexed_set "code we need to be able to use indexed_set"
#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;
template<typename T>
using indexed_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;
endsnippet

snippet segment_tree "generic segment tree"
template<typename TreeType, typename SourceType>
struct SegmentTree {
    int tree_size;
    vector<TreeType> tree;
    vector<SourceType> source_vector;
    TreeType neutral_element;
    function<TreeType(TreeType, TreeType)> combine;

    SegmentTree(vector<SourceType> &_source_vector, function<TreeType(TreeType, TreeType)> _combine, TreeType _neutral_element) {
        source_vector = _source_vector;
        tree_size = int(source_vector.size());
        neutral_element = _neutral_element;
        combine = _combine;

        while ((tree_size & -tree_size) != tree_size) {
            ++tree_size;
        }

        tree.resize(2 * tree_size);
    }

    void build(int node, int lo, int hi) {
        if (lo == hi) {
            tree[node] = source_vector[lo];
            return;
        }

        int mid = (lo + hi) / 2;
        build(2 * node + 1, lo, mid);
        build(2 * node + 2, mid + 1, hi);

        tree[node] = combine(tree[2 * node + 1], tree[2 * node + 2]);
    }

    TreeType query(int qlo, int qhi, int node, int lo, int hi) {
        if (qlo > hi || qhi < lo) {
            return neutral_element;
        }

        if (qlo <= lo && qhi >= hi) {
            return tree[node];
        }

        int mid = (lo + hi) / 2;
        return combine(query(qlo, qhi, 2 * node + 1, lo, mid), query(qlo, qhi, 2 * node + 2, mid + 1, hi));
    }

    void insert(int idx, int val, int node, int lo, int hi) {
        if (lo == hi) {
            tree[node] = val;
            return;
        }

        int mid = (lo + hi) / 2;
        if (idx <= mid) {
            insert(idx, val, 2 * node + 1, lo, mid);
        }

        else {
            insert(idx, val, 2 * node + 2, mid + 1, hi);
        }

        tree[node] = combine(tree[2 * node + 1], tree[2 * node + 2]);
    }
};
endsnippet

snippet sparse_table "code for sparse table"
const int LOG = 18;
int SparseTable[MAX][LOG];

void build(int n, vector<int> &a) {
    for (int i = 0; i < n; ++i) {
        SparseTable[i][0] = a[i];
    }

    for (int j = 1; j < LOG; ++j) {
        for (int i = 0; i + (1 << j) - 1 < n; ++i) {
            SparseTable[i][j] = min(SparseTable[i][j - 1], SparseTable[i + (1 << (j - 1))][j - 1]);
        }
    }
}

int query(int l, int r) {
    int len = r - l + 1;
    int k = 31 - __builtin_clz(len);
    return min(SparseTable[l][k], SparseTable[r - (1 << k) + 1][k]);
}
endsnippet

snippet floyd_warshall "code for floyd warshall"
void floydWarshall() {
    for (int k = 0; k < n; ++k) {
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (d[i][k] < INF && d[k][j] < INF) {
                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
                }
            }
        }
    }
}
endsnippet

snippet find_first_false "function that finds first false falue of function f (must be a function that satisfyes TTTTTTTT..FFFFFFFF)"
template <class Integer, class F>
Integer find_first_false(Integer l, Integer r, F&& f) {
    --l;
    ++r;
    while (r - l > 1) {
        Integer m = l + (r - l) / 2; // prefer std::midpoint in C++20
        if (f(m)) {
            l = m;
        } else {
            r = m;
        }
    }
    return r;
}
endsnippet

snippet lazy_propagation "code for segment tree with lazy_propagation"
struct lazy_segment_tree {
    vector<ll> tree, lazy;
    int N;

    lazy_segment_tree(const vector<int> &v) {
        N = int(v.size());
        tree.resize(4 * N);
        lazy.resize(4 * N);

        build(v, 0, 0, N - 1);
    }

    lazy_segment_tree(int n) {
        N = n;
        tree.resize(4 * N);
        lazy.resize(4 * N);
    }

    void build(const vector<int> &v, int node, int lo, int hi) {
        if (lo == hi) {
            tree[node] = v[lo];
            return;
        }

        int mid = (lo + hi) / 2;
        build(v, 2 * node + 1, lo, mid);
        build(v, 2 * node + 2, mid + 1, hi);
        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];
    }

    ll sum(int qlo, int qhi, int node, int lo, int hi) {
        if (lazy[node]) {
            tree[node] += (hi - lo + 1) * lazy[node];

            if (lo != hi) {
                lazy[2 * node + 1] += lazy[node];
                lazy[2 * node + 2] += lazy[node];
            }
            lazy[node] = 0;
        }

        if (qlo > hi || qhi < lo) {
            return 0;
        }

        if (qlo <= lo && qhi >= hi) {
            return tree[node];
        }

        int mid = (lo + hi) / 2;
        return sum(qlo, qhi, 2 * node + 1, lo, mid) + sum(qlo, qhi, 2 * node + 2, mid + 1, hi);
    }

    void update(int qlo, int qhi, ll val, int node, int lo, int hi) {
        if (lazy[node]) {
            tree[node] += (hi - lo + 1) * lazy[node];

            if (lo != hi) {
                lazy[2 * node + 1] += lazy[node];
                lazy[2 * node + 2] += lazy[node];
            }
            lazy[node] = 0;
        }

        if (qlo > hi || qhi < lo)
            return;

        if (qlo <= lo && qhi >= hi) {
            tree[node] += val * (hi - lo + 1);

            if (hi != lo) {
                lazy[2 * node + 1] += val;
                lazy[2 * node + 2] += val;
            }
            return;
        }

        int mid = (lo + hi) / 2;
        update(qlo, qhi, val, 2 * node + 1, lo, mid);
        update(qlo, qhi, val, 2 * node + 2, mid + 1, hi);

        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];
    }

    ll get(int idx, int node, int lo, int hi) {
        if (lazy[node]) {
            tree[node] += (hi - lo + 1) * lazy[node];

            if (lo != hi) {
                lazy[2 * node + 1] += lazy[node];
                lazy[2 * node + 2] += lazy[node];
            }
            lazy[node] = 0;
        }

        if (lo == hi)
            return tree[node];

        int mid = (lo + hi) / 2;
        if (idx <= mid)
            return get(idx, 2 * node + 1, lo, mid);

        else
            return get(idx, 2 * node + 2, mid + 1, hi);
    }

    ll sum(int qlo, int qhi) {
        return sum(qlo, qhi, 0, 0, N - 1);
    }

    void update(int qlo, int qhi, ll val) {
        update(qlo, qhi, val, 0, 0, N - 1);
    }

    ll get(int idx) {
        return get(idx, 0, 0, N - 1);
    }
};
endsnippet

snippet simple_template "simple template"
#include "bits/stdc++.h"
#define ff first
#define ss second
#define pb push_back
#define fastio() ios_base::sync_with_stdio(false); cin.tie(nullptr)
#define all(v) v.begin(),v.end()
#define rall(v) v.rbegin(),v.rend()

using namespace std;
using ll = long long;

const int MOD = 1e9 + 7, MOD1 = 998244353;
const int INF = 1e9 + 5, MAX = 2e5 + 5;

void run_case() {

}

int main() {
#ifndef LSHT_DEBUG
    fastio();
#endif
	cout << fixed << setprecision(16);

    int TESTS = 1;
    // cin >> TESTS;

    for (int i = 1; i <= TESTS; ++i) {
        run_case();
    }

    return 0;
}
endsnippet

snippet generate_random_input "description"
#include <bits/stdc++.h>
#define pb push_back
#define ff first
#define ss second

using namespace std;
using ll = long long;

const int MOD = 1e9 + 7, MOD1 = 998244353;
const int INF = 1e9 + 5, MAX = 2e5 + 5;

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
int random(int a, int b) {
    return a + rng() % (b - a + 1);
}

int main(int argc, char *argv[]) {
    // Create the input

    return 0;
}
endsnippet

snippet basic_template_for_cp_cpp "bigger template"
#include "bits/stdc++.h"
#define fastio() ios_base::sync_with_stdio(false); cin.tie(nullptr)
#define pb push_back
#define ff first
#define ss second
#define all(v) v.begin(),v.end()
#define rall(v) v.rbegin(),v.rend()

#ifdef LSHT_DEBUG
#define dbg(args...){ string _s = #args; replace(_s.begin(), _s.end(), ',', ' '); stringstream _ss(_s); istream_iterator<string> _it(_ss); err(_it, args); }
#else
#define dbg(args...)
#endif

using namespace std;
using ll = long long;

void err(istream_iterator<string> ) {cerr << "\n"; }
template<typename T, typename... Args>
void err(istream_iterator<string> it, T a, Args... args) {
    cerr << "\033[1;31m" << *it << " = " << a << "\033[0m" << ", ";
    err(++it, args...);
}

template <typename VectorType>
ostream &operator << (ostream &os, const vector<VectorType> &_vector_to_print) {
    os << "[";
    for (int i = 0; i < int(_vector_to_print.size()); ++i) {
        if (i > 0) os << ", ";
        os << _vector_to_print[i];
    }
    os << "]";
    return os;
}

const int MOD = 1e9 + 7, MOD1 = 998244353;
const int INF = 1e9 + 5, MAX = 2e5 + 5;

void run_case() {

}

int main() {
#ifndef LSHT_DEBUG
    fastio();
#endif
	cout << fixed << setprecision(16);

    int TESTS = 1;
    //cin >> TESTS;
    for (int i = 1; i <= TESTS; ++i) {
        run_case();
    }

    return 0;
}

/* stuff you should look for
    * int overflow, array bounds
    * special cases (n=1?)
    * do smth instead of nothing and stay organized
    * WRITE STUFF DOWN
    * DON'T GET STUCK ON ONE APPROACH
*/
endsnippet

snippet MillerRabin "Miller Rabin Primality test"
using u64 = uint64_t;
using u128 = __uint128_t;

u64 binpower(u64 base, u64 e, u64 mod) {
    u64 result = 1;
    base %= mod;
    while (e) {
        if (e & 1)
            result = (u128)result * base % mod;
        base = (u128)base * base % mod;
        e >>= 1;
    }
    return result;
}

bool check_composite(u64 n, u64 a, u64 d, int s) {
    u64 x = binpower(a, d, n);
    if (x == 1 || x == n - 1)
        return false;
    for (int r = 1; r < s; r++) {
        x = (u128)x * x % n;
        if (x == n - 1)
            return false;
    }
    return true;
};

bool MillerRabin(u64 n, int iter=5) { // returns true if n is probably prime, else returns false.
    if (n < 4)
        return n == 2 || n == 3;

    int s = 0;
    u64 d = n - 1;
    while ((d & 1) == 0) {
        d >>= 1;
        s++;
    }

    for (int i = 0; i < iter; i++) {
        int a = 2 + rand() % (n - 3);
        if (check_composite(n, a, d, s))
            return false;
    }
    return true;
}
endsnippet

snippet MilRab2 "Faster version of Miller Rabin test"
using u64 = uint64_t;
using u128 = __uint128_t;

u64 binpower(u64 base, u64 e, u64 mod) {
    u64 result = 1;
    base %= mod;
    while (e) {
        if (e & 1)
            result = (u128)result * base % mod;
        base = (u128)base * base % mod;
        e >>= 1;
    }
    return result;
}

bool check_composite(u64 n, u64 a, u64 d, int s) {
    u64 x = binpower(a, d, n);
    if (x == 1 || x == n - 1)
        return false;
    for (int r = 1; r < s; r++) {
        x = (u128)x * x % n;
        if (x == n - 1)
            return false;
    }
    return true;
};

bool MillerRabin(u64 n) { // returns true if n is prime, else returns false.
    if (n < 2)
        return false;

    int r = 0;
    u64 d = n - 1;
    while ((d & 1) == 0) {
        d >>= 1;
        r++;
    }

    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {
        if (n == a)
            return true;
        if (check_composite(n, a, d, r))
            return false;
    }
    return true;
}
endsnippet

snippet DSU "dsu code"
struct DSU {
    vector<int> fat, siz;
    int N;
    DSU(int nn) {
        N = nn;
        fat.resize(N);
        siz.assign(N, 1);
        iota(all(fat), 0);
    }

    int get(int x) {
        return (fat[x] == x ? x : fat[fat[x]] = get(fat[x]));
    }

    void join(int x, int y) {
        x = get(x);
        y = get(y);
        if (x == y) {
            return;
        }
        if (siz[x] < siz[y]) {
            swap(x, y);
        }
        fat[y] = x;
        siz[x] += siz[y];
    }
};
endsnippet

snippet mint "mod int struct"
struct mint{
    int val;
 
    mint(long long a = 0) : val(a % MOD) {if(val < 0) val += MOD; }
    mint(long long a, long long b) : val(a % MOD) {*this /= b; }
 
    mint &operator += (const mint &b) {val += b.val; if(val >= MOD) val -= MOD; return *this; };
    mint &operator ++ () {val += 1; if(val >= MOD) val -= MOD; return *this; };
    mint &operator -= (const mint &b) {val -= b.val; if(val < 0) val += MOD; return *this; };
    mint &operator -- () {val -= 1; if(val < 0) val += MOD; return *this; };
    mint &operator *= (const mint &b) {val = ((long long)val * b.val) % MOD; return *this; }
 
    friend mint mexp(mint a, long long b){
        mint c(1);
        for(; b > 0; b /= 2, a *= a) if(b & 1) c *= a;
        return c;
    }
 
    friend mint minv(const mint &a) {return mexp(a, MOD - 2); }
 
    mint &operator /= (const mint &b) {*this *= minv(b); return *this; }
 
    friend mint operator + (mint a, const mint &b) {return a += b; }
    friend mint operator - (mint a, const mint &b) {return a -= b; }
    friend mint operator - (const mint &a) {return 0 - a; }
    friend mint operator * (mint a, const mint &b) {return a *= b; }
    friend mint operator / (mint a, const mint &b) {return a /= b; }
    friend bool operator == (const mint &a, const mint &b) {return a.val == b.val; }
    friend bool operator != (const mint &a, const mint &b) {return a.val != b.val; }
    friend bool operator < (const mint &a, const mint &b) {return a.val < b.val; }
    friend bool operator > (const mint &a, const mint &b) {return a.val > b.val; }
    friend bool operator >= (const mint &a, const mint &b) {return a.val >= b.val; }
    friend bool operator <= (const mint &a, const mint &b) {return a.val <= b.val; }
 
    friend istream &operator >> (istream &is, mint &a) {long long b; is >> b; a = b; return is; }
    friend ostream &operator << (ostream &os, const mint &a) {return os << a.val; }
};
endsnippet

snippet SubstringHash "code template for substring hashing"
struct SingleHash {
    vector<int> suf, b;
    int mod;

    SingleHash(string s, int base = 153, int _mod = 1000000009) {
        int n = s.length();
        suf.assign(n + 1, 0); // suf[n] = 0
        b.assign(n + 1, 0);
        b[0] = 1;
        b[1] = base;
        mod = _mod;
        for (int i = n - 1; i >= 0; --i) {
            suf[i] = (s[i] + (ll)suf[i + 1] * b[1]) % mod;
        }
        for (int i = 2; i <= n; ++i) {
            b[i] = (ll)b[i - 1] * b[1] % mod;
        }
    }

    int substr(int l, int r) const { // [l, r]
        ll v = suf[l] - (ll)suf[r + 1] * b[r - l + 1];
        v %= mod;
        v += mod;
        v %= mod;
        return v;
    }
};
endsnippet

snippet find_cycle_directed_graph "find a cycle in directed graph"
bool cycle(int node, vector<int> &vis, vector<vector<int>> &adj) {
    if (vis[node] == 2) {
        return false;
    }
    if (vis[node] == 1) {
        return true;
    }
    vis[node] = 1;
    for (int nbr : adj[node]) {
        if (cycle(nbr, vis, adj)) {
            return true;
        }
    }

    vis[node] = 2;
    return false;
}
endsnippet

snippet rngint "random integer"
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
endsnippet

snippet rngll "random 64 bit integer"
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
endsnippet

snippet all_pairings "code to generate all ways to pair n elements"
bool paired[MAX];
int part[MAX], n, ans = 0, grid[MAX][MAX];

int val() { //process pairing.
    int cnt = 0;
    vector<bool> has(n + 1);
    for (int i = 1; i <= n; ++i) {
        if (!has[i]) {
            cnt ^= grid[i][part[i]];
            has[i] = has[part[i]] = true;
        }
    }
    return cnt;
}

void getPossibs() {
    int f = 1;
    while (paired[f] && f <= n) ++f;
	if (f == n + 1) {
		ans = max(ans, val());
	}
    for (int s = f + 1; s <= n; ++s) {
        if (!paired[s]) {
            paired[f] = paired[s] = 1;
            part[f] = s;
            part[s] = f;
            getPossibs();
            paired[f] = paired[s] = 0;
            part[f] = part[s] = 0;
        }
    }
}
endsnippet

snippet FenwickTreee "Binary indexed tree"
struct BIT {
    vector<ll> tree;
    int n;

    BIT(const vector<int> &v) {
        n = int(v.size());
        tree.resize(n);

        for (int i = 0; i < n; ++i) {
            add(i, v[i]);
        }
    }

    ll sum(int idx) {
        ll res = 0;
        for (int i = idx; i >= 0; i = (i & (i + 1)) - 1) {
            res += tree[i];
        }
        return res;
    }

    ll sum(int l, int r) {
        return sum(r) - (l == 0 ? 0 : sum(l - 1));
    }

    void add(int idx, ll val) {
        for (int i = idx; i < n; i = i | (i + 1)) {
            tree[i] += val;
        }
    }
};
endsnippet

snippet BigNum "Big Integer"
struct Bigint {
    string a;
    int sign;
 
    Bigint(){}
    void operator = (string b) {
        a= (b[0]=='-' ? b.substr(1) : b);
        reverse(a.begin(), a.end());
        (*this).Remove0(b[0]=='-' ? -1 : 1);
    }
    Bigint(string x) {(*this)=x;}
    Bigint(ll x) {(*this)=to_string(x);}
    void operator = (ll x){*this=to_string(x);}
 
    char operator[](int i){return a[i];}
    int size() {return a.size();}
    Bigint inverseSign() {sign*=-1; return (*this);}
 
    Bigint Remove0(int newSign) {
        sign = newSign;
        for(int i=a.size()-1; i>0 && a[i]=='0'; i--) a.pop_back();
        if(a.size()==1 && a[0]=='0') sign=1;
        return (*this);
    }
 
    bool operator == (Bigint x) {return sign==x.sign && a==x.a;}
    bool operator == (string x) {return *this==Bigint(x);}
    bool operator == (ll x)     {return *this==Bigint(x);}
    bool operator != (Bigint x) {return !(*this==x);}
    bool operator != (string x) {return !(*this==x);}
    bool operator != (ll x)     {return !(*this==x);}
 
    bool operator < (Bigint b) {
        if (sign!=b.sign) return sign<b.sign;
        if(a.size()!=b.size()) return a.size()*sign<b.size()*sign;
        for(int i=a.size()-1; i>=0; i--)
            if(a[i] != b[i]) return a[i]<b[i];
        return false;
    }
    bool operator <  (string x) {return *this<Bigint(x);}
    bool operator <  (ll x)     {return *this<Bigint(x);}
    bool operator <= (Bigint b) {return *this==b || *this<b;}
    bool operator <= (string b) {return *this==b || *this<b;}
    bool operator <= (ll b)     {return *this==b || *this<b;}
    bool operator >  (Bigint b) {return !(*this==b || *this<b);}
    bool operator >  (string x) {return !(*this==x || *this<x);}
    bool operator >  (ll b)     {return !(*this==b || *this<b);}
    bool operator >= (Bigint b) {return *this==b || *this>b;}
    bool operator >= (string b) {return *this==b || *this>b;}
    bool operator >= (ll b)     {return *this==b || *this>b;}
 
    Bigint operator + (Bigint b) {
        if(sign != b.sign) return (*this)-b.inverseSign();
        Bigint sum;
        for(int i=0, carry=0; i<a.size() || i<b.size() || carry; i++){
            if (i<a.size()) carry+=a[i]-'0';
            if (i<b.size()) carry+=b[i]-'0';
            sum.a += (carry % 10 + 48);
            carry /= 10;
        }
        return sum.Remove0(sign);
    }
    Bigint operator +  (string x) {return *this+Bigint(x);}
    Bigint operator +  (ll x)     {return *this+Bigint(x);}
    Bigint operator ++ (int) {*this+=1; return *this-1;}
    Bigint operator ++ ()    {*this+=1; return *this;}
      void operator += (Bigint x) {*this = *this+x;}
      void operator += (string x) {*this = *this+x;}
      void operator += (ll x)     {*this = *this+x;}
 
 
    Bigint operator - ( Bigint b ) {
        if(sign != b.sign) return (*this)+b.inverseSign();
        if(*this < b) return (b - *this).inverseSign();
        Bigint sub;
        for(int i=0,borrow=0; i<a.size(); i++) {
            borrow = a[i]-borrow-(i<b.size() ? b.a[i] : '0');
            sub.a += borrow>=0 ? borrow+'0' : borrow + 58;
            borrow = borrow>=0 ? 0:1;
        }
        return sub.Remove0(sign);
    }
    Bigint operator - (string x) {return *this-Bigint(x);}
    Bigint operator - (ll x)     {return *this-Bigint(x);}
    Bigint operator -- (int) {*this-=1; return *this+1;}
    Bigint operator -- ()    {*this-=1; return *this;}
      void operator -= (Bigint x) {*this = *this-x;}
      void operator -= (string x) {*this = *this-x;}
      void operator -= (ll x)     {*this = *this-x;}
 
    Bigint operator * (Bigint b) {
        Bigint mult("0");
        for(int i=0, k=a[i]; i<a.size(); i++, k=a[i]) {
            while(k-- -'0') mult=mult+b;
            b.a.insert(b.a.begin(),'0');
        }
        return mult.Remove0(sign * b.sign);
    }
    Bigint operator * (string x) {return *this*Bigint(x);}
    Bigint operator * (ll x)     {return *this*Bigint(x);}
      void operator *= (Bigint x) {*this = *this*x;}
      void operator *= (string x) {*this = *this*x;}
      void operator *= (ll x)     {*this = *this*x;}
 
    Bigint operator / (Bigint b) {
        if(b.size()==1 && b[0]=='0') b.a[0]/=(b[0]-'0');
        Bigint c("0"), d;
        for(int j=0; j<a.size(); j++) d.a += "0";
        int dSign = sign*b.sign; b.sign=1;
        for(int i=a.size()-1; i>=0; i--) {
            c.a.insert(c.a.begin(),'0');
            c=c+a.substr(i,1);
            while(!(c<b)) c=c-b, d.a[i]++;
        }
        return d.Remove0(dSign);
    }
    Bigint operator / (string x) {return *this/Bigint(x);}
    Bigint operator / (ll x)     {return *this/Bigint(x);}
      void operator /= (Bigint x) {*this = *this/x;}
      void operator /= (string x) {*this = *this/x;}
      void operator /= (ll x)     {*this = *this/x;}
 
    Bigint operator % (Bigint b) {
        if( b.size()==1 && b[0]=='0') b.a[0]/=(b[0]-'0') ;
        Bigint c("0");
        int cSign = sign*b.sign; b.sign=1;
        for( int i=a.size()-1; i>=0; i-- ) {
            c.a.insert( c.a.begin(),'0');
            c = c+a.substr(i,1);
            while(!(c<b)) c=c-b;
        }
        return c.Remove0(cSign);
    }
    Bigint operator % (string x) {return *this%Bigint(x);}
    Bigint operator % (ll x)     {return *this%Bigint(x);}
      void operator %= (Bigint x) {*this = *this%x;}
      void operator %= (string x) {*this = *this%x;}
      void operator %= (ll x)     {*this = *this%x;}
 
    void print() {
        string ans = "";
        if(sign==-1) ans += "-";
        for(int i=a.size()-1; i>=0; i--) ans += a[i];
        cout << ans;
    }
    friend istream& operator >>(istream &in,Bigint &x){
        string s; in>>s; x=s; return in;
    }
    friend ostream& operator <<(ostream &out,Bigint &x){
        if(x.sign==-1) putchar('-');
        for(int i=x.size()-1; i>=0; i--)
            putchar(x[i]);
        return out;
    }
 
    friend Bigint pow(Bigint base, Bigint pw){
        Bigint ans=1;
        while(pw!=0){
            if(pw%2 !=0) ans*=base;
            base*=base, pw/=2;
        }
        return ans;
    }
    friend Bigint pow(Bigint a, Bigint b,Bigint mod) {
        if (b==0) return Bigint(1);
        Bigint tmp=pow(a,b/2,mod);
        if ((b%2)==0) return (tmp*tmp)%mod;
        else return (((tmp*tmp)%mod)*a)%mod;
    }
    friend Bigint sqrt(Bigint x) {
        Bigint ans=x,tmp=(x+1)/2;
        while (tmp<ans) ans=tmp, tmp=(tmp+x/tmp)/2;
        return ans;
    }
    friend Bigint gcd(Bigint a,Bigint b){
        return a%b==0 ? b : gcd(b, a%b);
    }
    friend Bigint lcm(Bigint a,Bigint b){
        return a/gcd(a,b);
    }
};
endsnippet

